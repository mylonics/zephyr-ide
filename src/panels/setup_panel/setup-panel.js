// Zephyr IDE Setup Panel Client-Side Logic

const vscode = acquireVsCodeApi();

// Navigation Functions
function navigateToSubPage(page) {
    vscode.postMessage({
        command: 'navigateToPage',
        page: page
    });
}

function navigateToOverview() {
    vscode.postMessage({
        command: 'navigateToPage',
        page: 'overview'
    });
}

// Listen for messages from the extension
window.addEventListener('message', event => {
    const message = event.data;
    
    switch (message.command) {
        case 'showSubPage':
            showSubPage(message.content, message.page);
            break;
        case 'showOverview':
            showOverview();
            break;
        case 'sdkListResult':
            displaySDKList(message.data);
            break;
        case 'updateHostToolsStatus':
            updateHostToolsStatus(message.data, message.error);
            break;
        case 'hostToolsInstallProgress':
            showHostToolsProgress(message.message);
            break;
        case 'hostToolsInstallComplete':
            hideHostToolsProgress();
            break;
    }
});

/**
 * Escapes HTML to prevent XSS attacks
 * @param {string} text - Text to escape
 * @returns {string} - Escaped text
 */
function escapeHtml(text) {
    // Handle null, undefined, or non-string inputs
    if (text == null || typeof text !== 'string') {
        return '';
    }
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function showSubPage(content, page) {
    const overviewContainer = document.getElementById('overviewContainer');
    const subPageContainer = document.getElementById('subPageContainer');
    
    if (overviewContainer && subPageContainer) {
        // Hide overview and show sub-page
        overviewContainer.classList.add('hidden');
        
        // Use DOMParser to safely parse HTML content from trusted server-side source
        // Content is generated by TypeScript classes (HostToolsSubPage, SDKSubPage, WorkspaceSubPage)
        // which only use configuration values, not user input
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        const subPageContent = doc.body.firstChild;
        
        // Clear and append the parsed content
        subPageContainer.innerHTML = '';
        if (subPageContent) {
            subPageContainer.appendChild(subPageContent);
        }
        
        subPageContainer.classList.add('visible');
    }
}

function hideSubPage() {
    const overviewContainer = document.getElementById('overviewContainer');
    const subPageContainer = document.getElementById('subPageContainer');
    
    if (overviewContainer && subPageContainer) {
        // Show overview and hide sub-page
        subPageContainer.classList.remove('visible');
        overviewContainer.classList.remove('hidden');
        
        // Clear sub-page content after animation
        setTimeout(() => {
            subPageContainer.innerHTML = '';
        }, 300);
    }
}

function showOverview() {
    hideSubPage();
}

// Section Toggle Functions (kept for compatibility)
function toggleSection(sectionId) {
    const content = document.getElementById(sectionId + 'Content');
    const icon = document.getElementById(sectionId + 'Icon');

    if (content.classList.contains('expanded')) {
        content.classList.remove('expanded');
        icon.classList.remove('expanded');
    } else {
        content.classList.add('expanded');
        icon.classList.add('expanded');
    }
}

// Scroll to section function (kept for compatibility)
function scrollToSection(sectionId) {
    const section = document.getElementById(sectionId);
    if (section) {
        section.scrollIntoView({ behavior: 'smooth', block: 'start' });
        // Expand the section if it's collapsed
        const content = document.getElementById(sectionId + 'Content');
        const icon = document.getElementById(sectionId + 'Icon');
        if (content && icon && !content.classList.contains('expanded')) {
            content.classList.add('expanded');
            icon.classList.add('expanded');
        }
    }
}

// Host Tools Functions
function openHostToolsPanel() {
    vscode.postMessage({
        command: 'openHostToolsPanel'
    });
}

function markToolsComplete() {
    vscode.postMessage({
        command: 'markToolsComplete'
    });
}

// Command Functions
function openWingetInstall() {
    vscode.postMessage({
        command: 'openWingetLink'
    });
}

function openFolder() {
    vscode.postMessage({
        command: 'openFolder'
    });
}

function reinitializeWorkspace() {
    vscode.postMessage({
        command: 'reinitializeWorkspace'
    });
}

function installSDK() {
    vscode.postMessage({
        command: 'installSDK'
    });
}

function setupWestEnvironment() {
    vscode.postMessage({
        command: 'setupWestEnvironment'
    });
}

function westInit() {
    vscode.postMessage({
        command: 'westInit'
    });
}

function westUpdate() {
    vscode.postMessage({
        command: 'westUpdate'
    });
}

function manageWorkspace() {
    vscode.postMessage({
        command: 'manageWorkspace'
    });
}

// SDK Management Functions
function listSDKs() {
    // Show loading state in the sdkListContainer
    const containerDiv = document.getElementById('sdkListContainer');

    if (containerDiv) {
        containerDiv.innerHTML = '<div style="display: flex; align-items: center; gap: 8px; padding: 10px;"><div class="loading-spinner"></div><span>Loading SDK information...</span></div>';
    }

    vscode.postMessage({
        command: 'listSDKs'
    });
}

function displaySDKList(sdkData) {
    const containerDiv = document.getElementById('sdkListContainer');

    if (!containerDiv) {
        return;
    }

    if (!sdkData.success) {
        containerDiv.innerHTML = `
            <div style="padding: 15px; border: 1px solid var(--vscode-inputValidation-errorBorder); border-radius: 6px; background-color: var(--vscode-inputValidation-errorBackground); color: var(--vscode-inputValidation-errorForeground);">
                <strong>Error:</strong> ${escapeHtml(sdkData.error || 'Failed to list SDKs')}
            </div>
        `;
        return;
    }

    if (!sdkData.versions || sdkData.versions.length === 0) {
        containerDiv.innerHTML = `
            <div style="padding: 15px; border: 1px solid var(--vscode-panel-border); border-radius: 6px; background-color: var(--vscode-editor-background); color: var(--vscode-descriptionForeground); text-align: center;">
                No SDK versions found. Try installing an SDK first.
            </div>
        `;
        return;
    }

    let html = '';
    for (const version of sdkData.versions) {
        // Escape all user-provided data to prevent XSS
        const escapedVersion = escapeHtml(version.version || '');
        const escapedPath = escapeHtml(version.path || '');
        
        html += `
            <div class="sdk-version-card">
                <div class="sdk-version-header">
                    <div class="sdk-version-title">Zephyr SDK ${escapedVersion}</div>
                </div>
                <div class="sdk-path">${escapedPath}</div>
                
                ${version.installedToolchains && version.installedToolchains.length > 0 ? `
                    <div class="toolchain-section">
                        <div class="toolchain-section-title">Installed Toolchains (${version.installedToolchains.length}):</div>
                        <div class="toolchain-list">
                            ${version.installedToolchains.map(tc => `<span class="toolchain-tag">${escapeHtml(tc)}</span>`).join('')}
                        </div>
                    </div>
                ` : ''}
                
                ${version.availableToolchains && version.availableToolchains.length > 0 ? `
                    <div class="toolchain-section">
                        <div class="toolchain-section-title">Available Toolchains (${version.availableToolchains.length}):</div>
                        <div class="toolchain-list">
                            ${version.availableToolchains.map(tc => `<span class="toolchain-tag available">${escapeHtml(tc)}</span>`).join('')}
                        </div>
                    </div>
                ` : ''}
            </div>
        `;
    }

    containerDiv.innerHTML = html;
}

// Workspace Setup Functions - Now direct handlers
function workspaceSetupFromGit() {
    vscode.postMessage({
        command: 'workspaceSetupFromGit'
    });
}

function workspaceSetupFromWestGit() {
    vscode.postMessage({
        command: 'workspaceSetupFromWestGit'
    });
}

function workspaceSetupStandard() {
    vscode.postMessage({
        command: 'workspaceSetupStandard'
    });
}

function workspaceSetupFromCurrentDirectory() {
    vscode.postMessage({
        command: 'workspaceSetupFromCurrentDirectory'
    });
}

function workspaceSetupPicker() {
    vscode.postMessage({
        command: 'workspaceSetupPicker'
    });
}

/**
 * Opens the West configuration panel to detect existing west configurations
 * or create new west.yml files from templates
 */
function westConfig() {
    vscode.postMessage({
        command: 'westConfig'
    });
}

// Copy to clipboard function from data attribute
function copyToClipboardFromData(element) {
    const text = element.getAttribute('data-command');
    if (!text) {
        console.error('No command data found');
        return;
    }
    copyToClipboard(text, element);
}

// Copy to clipboard function
function copyToClipboard(text, element) {
    // Function to handle feedback
    function showFeedback(success = true) {
        const indicator = element.nextElementSibling;
        if (!indicator || !indicator.classList.contains('copy-indicator')) {
            return;
        }

        const originalText = indicator.textContent;
        const originalColor = indicator.style.color;

        if (success) {
            indicator.textContent = 'Copied!';
            indicator.style.color = 'var(--vscode-terminal-ansiGreen)';
        } else {
            indicator.textContent = 'Failed to copy';
            indicator.style.color = 'var(--vscode-terminal-ansiRed)';
        }

        setTimeout(() => {
            indicator.textContent = originalText;
            indicator.style.color = originalColor;
        }, 2000);
    }

    // Try modern clipboard API first
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(() => {
            showFeedback(true);
        }).catch(err => {
            console.error('Clipboard API failed:', err);
            // Try fallback
            tryFallback();
        });
    } else {
        // Use fallback directly
        tryFallback();
    }

    function tryFallback() {
        try {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            const successful = document.execCommand('copy');
            document.body.removeChild(textArea);

            showFeedback(successful);
            if (!successful) {
                console.error('Fallback copy failed');
            }
        } catch (err) {
            console.error('Fallback copy failed:', err);
            showFeedback(false);
        }
    }
}

// Host Tools Manager Functions
function refreshHostToolsStatus() {
    vscode.postMessage({
        command: 'checkHostToolsStatus'
    });
}

function installAllMissingTools() {
    vscode.postMessage({
        command: 'installAllMissingTools'
    });
}

function installSinglePackage(packageName) {
    vscode.postMessage({
        command: 'installPackage',
        packageName: packageName
    });
}

function installPackageManagerTool() {
    vscode.postMessage({
        command: 'installPackageManager'
    });
}

function updateHostToolsStatus(data, error) {
    const managerStatus = document.getElementById('manager-status');
    const packagesStatus = document.getElementById('packages-status');
    const installAllBtn = document.getElementById('install-all-btn');
    
    if (!managerStatus || !packagesStatus) {
        return;
    }
    
    if (error) {
        managerStatus.innerHTML = `<div class="error">Error: ${escapeHtml(error)}</div>`;
        packagesStatus.innerHTML = `<div class="error">Unable to check package status</div>`;
        return;
    }
    
    // Update package manager status
    if (!data.managerAvailable) {
        managerStatus.innerHTML = `
            <div class="warning">
                <strong>${escapeHtml(data.managerName)}</strong> is not installed or not in PATH.
                <div style="margin-top: 10px;">
                    <button class="button button-secondary" onclick="installPackageManagerTool()">
                        Install ${escapeHtml(data.managerName)}
                    </button>
                </div>
            </div>
        `;
    } else {
        managerStatus.innerHTML = `
            <div class="success">
                ✓ <strong>${escapeHtml(data.managerName)}</strong> is available
            </div>
        `;
    }
    
    // Update packages status
    if (!data.packages || data.packages.length === 0) {
        packagesStatus.innerHTML = '<div class="info">No packages to check</div>';
        return;
    }
    
    let html = '<table class="packages-table">';
    html += '<thead><tr><th>Package</th><th>Status</th><th>Action</th></tr></thead><tbody>';
    
    let hasMissing = false;
    for (const pkg of data.packages) {
        const available = pkg.available;
        const statusClass = available ? 'success' : 'error';
        const statusText = available ? '✓ Installed' : '✗ Not installed';
        
        if (!available) {
            hasMissing = true;
        }
        
        html += `<tr>
            <td><strong>${escapeHtml(pkg.name)}</strong></td>
            <td><span class="${statusClass}">${statusText}</span></td>
            <td>`;
        
        if (!available) {
            html += `<button class="button button-small" onclick="installSinglePackage('${escapeHtml(pkg.name)}')">Install</button>`;
        }
        
        html += `</td></tr>`;
    }
    
    html += '</tbody></table>';
    packagesStatus.innerHTML = html;
    
    // Enable/disable install all button
    if (installAllBtn) {
        installAllBtn.disabled = !hasMissing || !data.managerAvailable;
    }
}

function showHostToolsProgress(message) {
    const progressSection = document.getElementById('progress-section');
    const progressMessage = document.getElementById('progress-message');
    
    if (progressSection && progressMessage) {
        progressMessage.textContent = message;
        progressSection.style.display = 'block';
    }
}

function hideHostToolsProgress() {
    const progressSection = document.getElementById('progress-section');
    if (progressSection) {
        progressSection.style.display = 'none';
    }
    // Refresh status after installation
    refreshHostToolsStatus();
}

// Message Listener
window.addEventListener('message', event => {
    const message = event.data;

    if (message.command === 'sdkListResult') {
        displaySDKList(message.data);
    }
});
