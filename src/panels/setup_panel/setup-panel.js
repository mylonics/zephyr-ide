// Zephyr IDE Setup Panel Client-Side Logic

const vscode = acquireVsCodeApi();

// State tracking for host tools installation
let hostToolsInstallationState = {
    packageStates: {} // Store state for each package (installing, pending-restart, etc.)
};

// Navigation Functions
function navigateToSubPage(page) {
    vscode.postMessage({
        command: 'navigateToPage',
        page: page
    });
}

function navigateToOverview() {
    vscode.postMessage({
        command: 'navigateToPage',
        page: 'overview'
    });
}

// Listen for messages from the extension
window.addEventListener('message', event => {
    const message = event.data;
    
    switch (message.command) {
        case 'showSubPage':
            showSubPage(message.content, message.page);
            break;
        case 'showOverview':
            showOverview();
            break;
        case 'sdkListResult':
            displaySDKList(message.data);
            break;
        case 'updateHostToolsStatus':
            updateHostToolsStatus(message.data, message.error);
            break;
        case 'hostToolsInstallProgress':
            showHostToolsProgress(message.message);
            break;
        case 'hostToolsInstallComplete':
            hideHostToolsProgress();
            break;
        case 'hostToolsInstallAllStarted':
            handleHostToolsInstallAllStarted(message.total);
            break;
        case 'hostToolsPackageInstalling':
            handleHostToolsPackageInstalling(message.packageName, message.current, message.total);
            break;
        case 'hostToolsPackageInstalled':
            handleHostToolsPackageInstalled(message.packageName, message.success, message.pendingRestart, message.current, message.total);
            break;
        case 'hostToolsInstallAllComplete':
            handleHostToolsInstallAllComplete(message.needsRestart, message.hasErrors);
            break;
        case 'westYmlContent':
            loadWestYmlContent(message.content);
            break;
    }
});

/**
 * Escapes HTML to prevent XSS attacks
 * @param {string} text - Text to escape
 * @returns {string} - Escaped text
 */
function escapeHtml(text) {
    // Handle null, undefined, or non-string inputs
    if (text == null || typeof text !== 'string') {
        return '';
    }
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function showSubPage(content, page) {
    const overviewContainer = document.getElementById('overviewContainer');
    const subPageContainer = document.getElementById('subPageContainer');
    
    if (overviewContainer && subPageContainer) {
        // Hide overview and show sub-page
        overviewContainer.classList.add('hidden');
        
        // Use DOMParser to safely parse HTML content from trusted server-side source
        // Content is generated by TypeScript classes (HostToolsSubPage, SDKSubPage, WorkspaceSubPage)
        // which only use configuration values, not user input
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        const subPageContent = doc.body.firstChild;
        
        // Clear and append the parsed content
        subPageContainer.innerHTML = '';
        if (subPageContent) {
            subPageContainer.appendChild(subPageContent);
        }
        
        subPageContainer.classList.add('visible');
    }
}

function hideSubPage() {
    const overviewContainer = document.getElementById('overviewContainer');
    const subPageContainer = document.getElementById('subPageContainer');
    
    if (overviewContainer && subPageContainer) {
        // Show overview and hide sub-page
        subPageContainer.classList.remove('visible');
        overviewContainer.classList.remove('hidden');
        
        // Clear sub-page content after animation
        setTimeout(() => {
            subPageContainer.innerHTML = '';
        }, 300);
    }
}

function showOverview() {
    hideSubPage();
}

// Section Toggle Functions (kept for compatibility)
function toggleSection(sectionId) {
    const content = document.getElementById(sectionId + 'Content');
    const icon = document.getElementById(sectionId + 'Icon');

    if (content.classList.contains('expanded')) {
        content.classList.remove('expanded');
        icon.classList.remove('expanded');
    } else {
        content.classList.add('expanded');
        icon.classList.add('expanded');
    }
}

// Scroll to section function (kept for compatibility)
function scrollToSection(sectionId) {
    const section = document.getElementById(sectionId);
    if (section) {
        section.scrollIntoView({ behavior: 'smooth', block: 'start' });
        // Expand the section if it's collapsed
        const content = document.getElementById(sectionId + 'Content');
        const icon = document.getElementById(sectionId + 'Icon');
        if (content && icon && !content.classList.contains('expanded')) {
            content.classList.add('expanded');
            icon.classList.add('expanded');
        }
    }
}

// Host Tools Functions
function openHostToolsPanel() {
    vscode.postMessage({
        command: 'openHostToolsPanel'
    });
}

function markToolsComplete() {
    vscode.postMessage({
        command: 'markToolsComplete'
    });
}

// Command Functions
function openWingetInstall() {
    vscode.postMessage({
        command: 'openWingetLink'
    });
}

function openFolder() {
    vscode.postMessage({
        command: 'openFolder'
    });
}

function reinitializeWorkspace() {
    vscode.postMessage({
        command: 'reinitializeWorkspace'
    });
}

function installSDK() {
    vscode.postMessage({
        command: 'installSDK'
    });
}

function setupWestEnvironment() {
    vscode.postMessage({
        command: 'setupWestEnvironment'
    });
}

function westInit() {
    vscode.postMessage({
        command: 'westInit'
    });
}

function westUpdate() {
    vscode.postMessage({
        command: 'westUpdate'
    });
}

function manageWorkspace() {
    vscode.postMessage({
        command: 'manageWorkspace'
    });
}

function selectExistingWestWorkspace() {
    vscode.postMessage({
        command: 'selectExistingWestWorkspace'
    });
}

// SDK Management Functions
function listSDKs() {
    // Show loading state in the sdkListContainer
    const containerDiv = document.getElementById('sdkListContainer');

    if (containerDiv) {
        containerDiv.innerHTML = '<div style="display: flex; align-items: center; gap: 8px; padding: 10px;"><div class="loading-spinner"></div><span>Loading SDK information...</span></div>';
    }

    vscode.postMessage({
        command: 'listSDKs'
    });
}

function displaySDKList(sdkData) {
    const containerDiv = document.getElementById('sdkListContainer');

    if (!containerDiv) {
        return;
    }

    if (!sdkData.success) {
        containerDiv.innerHTML = `
            <div style="padding: 15px; border: 1px solid var(--vscode-inputValidation-errorBorder); border-radius: 6px; background-color: var(--vscode-inputValidation-errorBackground); color: var(--vscode-inputValidation-errorForeground);">
                <strong>Error:</strong> ${escapeHtml(sdkData.error || 'Failed to list SDKs')}
            </div>
        `;
        return;
    }

    if (!sdkData.versions || sdkData.versions.length === 0) {
        containerDiv.innerHTML = `
            <div style="padding: 15px; border: 1px solid var(--vscode-panel-border); border-radius: 6px; background-color: var(--vscode-editor-background); color: var(--vscode-descriptionForeground); text-align: center;">
                No SDK versions found. Try installing an SDK first.
            </div>
        `;
        return;
    }

    let html = '';
    for (const version of sdkData.versions) {
        // Escape all user-provided data to prevent XSS
        const escapedVersion = escapeHtml(version.version || '');
        const escapedPath = escapeHtml(version.path || '');
        
        html += `
            <div class="sdk-version-card">
                <div class="sdk-version-header">
                    <div class="sdk-version-title">Zephyr SDK ${escapedVersion}</div>
                </div>
                <div class="sdk-path">${escapedPath}</div>
                
                ${version.installedToolchains && version.installedToolchains.length > 0 ? `
                    <div class="toolchain-section">
                        <div class="toolchain-section-title">Installed Toolchains (${version.installedToolchains.length}):</div>
                        <div class="toolchain-list">
                            ${version.installedToolchains.map(tc => `<span class="toolchain-tag">${escapeHtml(tc)}</span>`).join('')}
                        </div>
                    </div>
                ` : ''}
                
                ${version.availableToolchains && version.availableToolchains.length > 0 ? `
                    <div class="toolchain-section">
                        <div class="toolchain-section-title">Available Toolchains (${version.availableToolchains.length}):</div>
                        <div class="toolchain-list">
                            ${version.availableToolchains.map(tc => `<span class="toolchain-tag available">${escapeHtml(tc)}</span>`).join('')}
                        </div>
                    </div>
                ` : ''}
            </div>
        `;
    }

    containerDiv.innerHTML = html;
}

// Workspace Setup Functions - Now direct handlers
function workspaceSetupFromGit() {
    vscode.postMessage({
        command: 'workspaceSetupFromGit'
    });
}

function workspaceSetupFromWestGit() {
    vscode.postMessage({
        command: 'workspaceSetupFromWestGit'
    });
}

function workspaceSetupStandard() {
    vscode.postMessage({
        command: 'workspaceSetupStandard'
    });
}

function workspaceSetupFromCurrentDirectory() {
    vscode.postMessage({
        command: 'workspaceSetupFromCurrentDirectory'
    });
}

function workspaceSetupPicker() {
    vscode.postMessage({
        command: 'workspaceSetupPicker'
    });
}

/**
 * Opens the West configuration panel to detect existing west configurations
 * or create new west.yml files from templates
 */
function westConfig() {
    vscode.postMessage({
        command: 'westConfig'
    });
}

// West.yml editor functions
function openWestYml() {
    vscode.postMessage({
        command: 'openWestYml'
    });
}

function saveAndUpdateWestYml() {
    const editor = document.getElementById('westYmlEditor');
    if (editor) {
        const content = editor.value;
        vscode.postMessage({
            command: 'saveAndUpdateWestYml',
            content: content
        });
    }
}

function loadWestYmlContent(content) {
    const editor = document.getElementById('westYmlEditor');
    if (editor) {
        editor.value = content || '';
        
        // Add tab key handler if not already added
        if (!editor.dataset.tabHandlerAdded) {
            editor.addEventListener('keydown', function(e) {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    
                    // Get cursor position
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    
                    // Insert two spaces at cursor position
                    const value = this.value;
                    this.value = value.substring(0, start) + '  ' + value.substring(end);
                    
                    // Move cursor after the inserted spaces
                    this.selectionStart = this.selectionEnd = start + 2;
                }
            });
            editor.dataset.tabHandlerAdded = 'true';
        }
    }
}

// Copy to clipboard function from data attribute
function copyToClipboardFromData(element) {
    const text = element.getAttribute('data-command');
    if (!text) {
        console.error('No command data found');
        return;
    }
    copyToClipboard(text, element);
}

// Copy to clipboard function
function copyToClipboard(text, element) {
    // Function to handle feedback
    function showFeedback(success = true) {
        const indicator = element.nextElementSibling;
        if (!indicator || !indicator.classList.contains('copy-indicator')) {
            return;
        }

        const originalText = indicator.textContent;
        const originalColor = indicator.style.color;

        if (success) {
            indicator.textContent = 'Copied!';
            indicator.style.color = 'var(--vscode-terminal-ansiGreen)';
        } else {
            indicator.textContent = 'Failed to copy';
            indicator.style.color = 'var(--vscode-terminal-ansiRed)';
        }

        setTimeout(() => {
            indicator.textContent = originalText;
            indicator.style.color = originalColor;
        }, 2000);
    }

    // Try modern clipboard API first
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(() => {
            showFeedback(true);
        }).catch(err => {
            console.error('Clipboard API failed:', err);
            // Try fallback
            tryFallback();
        });
    } else {
        // Use fallback directly
        tryFallback();
    }

    function tryFallback() {
        try {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            const successful = document.execCommand('copy');
            document.body.removeChild(textArea);

            showFeedback(successful);
            if (!successful) {
                console.error('Fallback copy failed');
            }
        } catch (err) {
            console.error('Fallback copy failed:', err);
            showFeedback(false);
        }
    }
}

// Host Tools Manager Functions
function refreshHostToolsStatus() {
    vscode.postMessage({
        command: 'checkHostToolsStatus'
    });
}

function installAllMissingTools() {
    vscode.postMessage({
        command: 'installAllMissingTools'
    });
}

function installSinglePackage(packageName) {
    vscode.postMessage({
        command: 'installPackage',
        packageName: packageName
    });
}

function installPackageManagerTool() {
    vscode.postMessage({
        command: 'installPackageManager'
    });
}

function updateHostToolsStatus(data, error) {
    const managerStatus = document.getElementById('manager-status');
    const packagesStatus = document.getElementById('packages-status');
    const installAllBtn = document.getElementById('install-all-btn');
    
    if (!managerStatus || !packagesStatus) {
        return;
    }
    
    if (error) {
        managerStatus.innerHTML = `<div class="error">Error: ${escapeHtml(error)}</div>`;
        packagesStatus.innerHTML = `<div class="error">Unable to check package status</div>`;
        return;
    }
    
    // Update package manager status
    if (!data.managerAvailable) {
        managerStatus.innerHTML = `
            <div class="warning">
                <strong>${escapeHtml(data.managerName)}</strong> is not installed or not in PATH.
                <div style="margin-top: 10px;">
                    <button class="button button-secondary" onclick="installPackageManagerTool()">
                        Install ${escapeHtml(data.managerName)}
                    </button>
                </div>
            </div>
        `;
    } else {
        managerStatus.innerHTML = `
            <div class="success">
                ✓ <strong>${escapeHtml(data.managerName)}</strong> is available
            </div>
        `;
    }
    
    // Update packages status
    if (!data.packages || data.packages.length === 0) {
        packagesStatus.innerHTML = '<div class="info">No packages to check</div>';
        return;
    }
    
    let html = '<table class="packages-table">';
    html += '<thead><tr><th>Package</th><th>Status</th><th>Action</th></tr></thead><tbody>';
    
    let hasMissing = false;
    for (const pkg of data.packages) {
        // Check if this package has a saved pending-restart state
        const savedState = hostToolsInstallationState.packageStates[pkg.name];
        const isPendingRestart = savedState === 'pending-restart';
        const isInstalling = savedState === 'installing';
        
        // Determine the actual state to display
        let statusClass, statusText, showInstallButton;
        
        if (isInstalling) {
            statusClass = 'info';
            statusText = '<span class="codicon codicon-sync codicon-modifier-spin"></span> Installing';
            showInstallButton = false;
        } else if (isPendingRestart) {
            statusClass = 'warning';
            statusText = '<span class="codicon codicon-warning"></span> Not Available Pending Restart';
            showInstallButton = false;
        } else if (pkg.available) {
            statusClass = 'success';
            statusText = '✓ Installed';
            showInstallButton = false;
        } else {
            statusClass = 'error';
            statusText = '✗ Not Available';
            showInstallButton = true;
            hasMissing = true;
        }
        
        html += `<tr>
            <td><strong>${escapeHtml(pkg.name)}</strong></td>
            <td><span class="${statusClass}">${statusText}</span></td>
            <td>`;
        
        if (showInstallButton) {
            html += `<button class="button button-small" onclick="installSinglePackage('${escapeHtml(pkg.name)}')">Install</button>`;
        }
        
        html += `</td></tr>`;
    }
    
    html += '</tbody></table>';
    packagesStatus.innerHTML = html;
    
    // Enable/disable install all button
    if (installAllBtn) {
        installAllBtn.disabled = !hasMissing || !data.managerAvailable;
    }
}

function showHostToolsProgress(message) {
    const progressSection = document.getElementById('progress-section');
    const progressMessage = document.getElementById('progress-message');
    
    if (progressSection && progressMessage) {
        progressMessage.textContent = message;
        progressSection.style.display = 'block';
    }
}

function hideHostToolsProgress() {
    const progressSection = document.getElementById('progress-section');
    if (progressSection) {
        progressSection.style.display = 'none';
    }
    // Refresh status after installation
    refreshHostToolsStatus();
}

function handleHostToolsInstallAllStarted(total) {
    const installAllBtn = document.getElementById('install-all-btn');
    if (installAllBtn) {
        installAllBtn.disabled = true;
        installAllBtn.innerHTML = `
            <span class="codicon codicon-sync codicon-modifier-spin"></span>
            Installing Packages (0/${total})
        `;
    }
}

function handleHostToolsPackageInstalling(packageName, current, total) {
    // Update the button text only if installing multiple packages
    if (total > 1) {
        const installAllBtn = document.getElementById('install-all-btn');
        if (installAllBtn) {
            // Ensure values are numbers to prevent XSS
            const currentNum = Number(current);
            const totalNum = Number(total);
            installAllBtn.innerHTML = `
                <span class="codicon codicon-sync codicon-modifier-spin"></span>
                Installing Packages (${currentNum}/${totalNum})
            `;
        }
    }
    
    // Save the state and update the specific package row in the table
    hostToolsInstallationState.packageStates[packageName] = 'installing';
    updateHostToolsPackageStatus(packageName, 'installing');
}

function handleHostToolsPackageInstalled(packageName, success, pendingRestart, current, total) {
    // Update and save package state
    let state = 'error';
    if (success && !pendingRestart) {
        state = 'installed';
    } else if (success && pendingRestart) {
        state = 'pending-restart';
    }
    
    hostToolsInstallationState.packageStates[packageName] = state;
    updateHostToolsPackageStatus(packageName, state);
}

function handleHostToolsInstallAllComplete(needsRestart, hasErrors) {
    const installAllBtn = document.getElementById('install-all-btn');
    if (installAllBtn) {
        if (needsRestart) {
            installAllBtn.innerHTML = `
                <span class="codicon codicon-warning"></span>
                Pending Restart
            `;
        } else if (hasErrors) {
            installAllBtn.innerHTML = `
                <span class="codicon codicon-error"></span>
                Installation Failed
            `;
        } else {
            installAllBtn.innerHTML = `
                <span class="codicon codicon-check"></span>
                All Packages Installed
            `;
        }
        
        // Re-enable button after a delay
        setTimeout(() => {
            installAllBtn.disabled = false;
            refreshHostToolsStatus();
        }, 2000);
    }
}

function updateHostToolsPackageStatus(packageName, state) {
    const packagesTable = document.querySelector('.packages-table');
    if (!packagesTable) {
        return;
    }
    
    const rows = packagesTable.querySelectorAll('tbody tr');
    for (const row of rows) {
        const nameCell = row.querySelector('td:first-child strong');
        if (nameCell && nameCell.textContent.trim() === packageName) {
            const statusCell = row.querySelector('td:nth-child(2)');
            const actionCell = row.querySelector('td:nth-child(3)');
            
            if (!statusCell) {
                continue;
            }
            
            // Update status text and style
            switch (state) {
                case 'installing':
                    statusCell.innerHTML = '<span class="info"><span class="codicon codicon-sync codicon-modifier-spin"></span> Installing</span>';
                    if (actionCell) {
                        actionCell.innerHTML = '';
                    }
                    break;
                case 'installed':
                    statusCell.innerHTML = '<span class="success">✓ Installed</span>';
                    if (actionCell) {
                        actionCell.innerHTML = '';
                    }
                    break;
                case 'pending-restart':
                    statusCell.innerHTML = '<span class="warning"><span class="codicon codicon-warning"></span> Not Available Pending Restart</span>';
                    if (actionCell) {
                        actionCell.innerHTML = '';
                    }
                    break;
                case 'error':
                    statusCell.innerHTML = '<span class="error">✗ Installation Failed</span>';
                    break;
            }
            break;
        }
    }
}

// Message Listener
window.addEventListener('message', event => {
    const message = event.data;

    if (message.command === 'sdkListResult') {
        displaySDKList(message.data);
    }
});
